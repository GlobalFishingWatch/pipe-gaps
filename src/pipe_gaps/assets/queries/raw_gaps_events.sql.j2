#standardSQL

-- Include some utility functions
{% include 'utils.sql.j2' %}

-- Parameters of this query:
-- * source_voyages
-- * source_port_visits
-- * source_raw_gaps
-- * source_segment_info
-- * source_regions_table
-- * source_all_vessels_byyear
-- * start_date

WITH

    #################
    # Voyages source 
    #################
    voyages_source as (
        SELECT
            *,
        FROM `{{ source_voyages }}`
    ),

    
    # We need to flatten voyages so that we have a record for each vessel id
    flattened_voyages AS (
        SELECT
            trip_id,
            trip_start,
            trip_end,
            trip_start_anchorage_id,
            trip_end_anchorage_id,
            trip_end_visit_id,
            vessel_id
        FROM voyages_source
        WHERE trip_start != '1979-01-01' OR trip_start IS NULL
    ),

    ########################################################
    # Port visits source, replacing named achorages source #
    ########################################################
    port_visit_source as (
        SELECT
            JSON_EXTRACT_SCALAR(event_info, "$.visit_id") as visit_id,
            *,
        FROM `{{ source_port_visits }}`
    ),


    ############
    # Raw gaps #
    ############
    source_raw_gaps AS (
        SELECT
            *
        FROM
            `{{ source_raw_gaps }}`
          1=1
        {% if start_date %}
          AND DATE(start_timestamp) >= '{{ start_date }}'
        {% endif %}

        {% if end_date %}
          AND DATE(end_timestamp) < '{{ end_date }}'
        {% endif %}
    ),

    ############
    # Segments #
    ############
    source_segment_info AS (
        SELECT
            *
        FROM
            `{{ source_segment_info }}`
    ),

    ################
    # Regions data #
    ################
    regions_source as (
        SELECT
            *,
        FROM `{{ source_regions_table }}`
    ),

    gridded_regions AS (
        SELECT
            * EXCEPT(s2_cells),
        FROM regions_source
            CROSS JOIN UNNEST (s2_cells) AS s2_cell
    ),

    ##########################
    # Vessels byyear sources #
    ##########################
    source_all_vessels AS (
        SELECT
            *
        FROM `{{ source_all_vessels_byyear }}`
    ),

    ############### Create base event table ################
    # * Compute event_id.                                  # 
    # * Get base common information.                       # 
    # * Add event_type, vessel_id, seg_id.                 # 
    # * Calculate lat_mean, lot_mean.                      # 
    # * Add vessels, voyages, and port visits information. #
    # * Convert distances to km.                           # 
    ########################################################
    base_raw_gaps_event AS (
        SELECT
            TO_HEX(MD5(FORMAT("%s|%s|%t|%t",'raw_gaps', vessels.vessel_id, start_timestamp, end_timestamp))) AS event_id,
            'raw_gaps' AS event_type,
            vessels.vessel_id,
            segment_info.seg_id,
            start_timestamp AS event_start,
            end_timestamp AS event_end,
            (start_lat + end_lat) / 2 AS lat_mean,
            (start_lon + end_lon) / 2 AS lon_mean,
            start_lat AS lat_min,
            start_lon AS lon_min,
            end_lat AS lat_max,
            end_lon AS lon_max,
            TO_JSON_STRING(
                STRUCT(
                    duration_h,
                    convert_m_to_km(distance_m) AS total_distance_km,
                    implied_speed_knots,
                    vessels.prod_shiptype as vessel_class,
                    STRUCT(
                    -- destination port after event
                        vessel_trip_end_anchorages.event_id AS event_id,
                        SAFE.STRING(PARSE_JSON(vessel_trip_end_anchorages.event_info, wide_number_mode=>'round').intermediate_anchorage.id) as id,
                        SAFE.STRING(PARSE_JSON(vessel_trip_end_anchorages.event_info, wide_number_mode=>'round').intermediate_anchorage.flag) as flag,
                        SAFE.STRING(PARSE_JSON(vessel_trip_end_anchorages.event_info, wide_number_mode=>'round').intermediate_anchorage.name) as name
                    ) as main_vessel_destination_port
                )
            ) AS event_info,
            TO_JSON_STRING([
                STRUCT(
                    vessels.vessel_id AS `id`,
                    raw_gaps.ssvid AS `ssvid`,
                    vessels.shipname AS `name`,
                    segment_info.seg_id,
                    vessels.prod_shiptype AS `type`,
                    vessels.mmsi_flag AS `flag`
                )
            ]) AS event_vessels
        FROM source_raw_gaps AS raw_gaps
            # Join raw_gaps with segments. 
            JOIN source_segment_info AS segment_info ON
                raw_gaps.start_seg_id = segment_info.seg_id

            # Join segments with vessels.
            JOIN source_all_vessels AS vessels USING (vessel_id, year)

            # Join vessels with voyages.
            LEFT JOIN flattened_voyages AS voyages ON ( 
                vessels.vessel_id = voyages.vessel_id 
                AND (voyages.trip_start < start_timestamp OR voyages.trip_start IS NULL)
                AND voyages.trip_end > end_timestamp 
            )

            # Join voyages with port port visits.
            LEFT JOIN  port_visit_source AS vessel_trip_end_anchorages ON
                voyages.trip_end_visit_id = vessel_trip_end_anchorages.visit_id
    ),


    #
    # Finally, enhance the event with info related to regions and distances.
    #
    total_events AS (
        SELECT
            event_id,
            event_type,
            vessel_id,
            seg_id,
            event_start,
            event_end,
            lat_mean,
            lon_mean,
            lat_min,
            lon_min,
            lat_max,
            lon_max,
            event_info,
            event_vessels,
            ST_GEOGPOINT(lon_mean, lat_mean) as geo,
            S2_CELLIDFROMPOINT(ST_GEOGPOINT(lon_mean, lat_mean), s2_level()) as s2_cell,
            convert_m_to_km(start_distance_from_shore_m) AS start_distance_from_shore_km,
            convert_m_to_km(end_distance_from_shore_m) AS end_distance_from_shore_km,
            convert_m_to_km(start_distance_from_port_m) AS start_distance_from_port_km,
            convert_m_to_km(distance_from_port_m) AS end_distance_from_port_km,
        FROM
            base_raw_gaps_event
    ),

    # Match events with regions geographically.
    create_event_region_matches AS (
        SELECT
            events.event_id,
            id,
            layer,
        FROM
            total_events AS events
            JOIN gridded_regions r ON events.s2_cell = r.s2_cell
        WHERE ST_INTERSECTS(events.geo, r.geo)
    ),

    # Group events by event_id, layer, and id
    event_by_layer_by_id AS (
        SELECT
            event_id,
            layer,
            id
        FROM create_event_region_matches
        GROUP BY
            1,
            2,
            3
    ),

    # Group events by layer.
    events_by_layer AS (
        SELECT
            event_id, CONCAT('"', layer, '":' ,TO_JSON_STRING(array_agg(id))) AS json_frament
        FROM event_by_layer_by_id
        GROUP BY
            event_id,
            layer
    ),

    # Enrich events with regions.
    event_with_region AS (
        SELECT
            event_id,
            parse_regions_to_struct(CONCAT( "{", STRING_AGG(json_frament, ","), "}")) AS regions
        FROM events_by_layer
        GROUP BY
            1
    )

    # Enrich events with regions.
    SELECT
        total_events.* EXCEPT (s2_cell, geo),
        event_with_region.regions AS regions_mean_position
    FROM
        total_events
        LEFT JOIN event_with_region USING (event_id)